# -*- coding: utf-8 -*-
"""CR.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KyOeaHqqmTCW7QOkLyi7fVuFCoyfO1i6
"""

from math import *
import matplotlib.pyplot as histo
import json
import plotly.graph_objs as go
import plotly.io as pio
import os
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
from scipy.stats import pearsonr
import pandas as pd
import plotly.express as px

##################################################################################################################
########################################################## Valeur moyenne ########################################
##################################################################################################################

###### Somme des valeurs de la liste divisées par le nombre d'éléments (vu que je transmet une liste, je divise par la taille de la liste).
def valmoy(x):
    sum = 0
    for values in x:
        sum+=values
    moy=sum/len(x)
    return moy

# Utilistion : mettre en parammetre de cette fonction une liste.

# Cette fonction va juste faire la moyenne d'une liste :
# Somme de tout les éléments de la liste divisé par le nombre de valeur

def allmoy(lst):
    count = len(lst)
    somme = sum(lst)
    return round(somme / count, 0)

# Utilistion : mettre en parammetre de cette fonction une liste.

##################################################################################################################
########################################################## Variance ##############################################
##################################################################################################################

###### Je prends en  argument une liste  de longueur n
###### Variance - Je récupère la liste, j'appelle la fonction pour trouver la moyenne, je prends toutes les valeurs
###### du tableau, je leur soustrait la moyenne et j'élève le tout au carré, j'ajoute tout dans une variable et je
###### divise par la longueur du tableau, (j'arrondi à 2 chiffres après la virgule). Je retourne aussi la liste des
###### valeurs intermédiaires L qui va m'être utile pour la covariance

def variance(liste):
    var=0
    val=valmoy(liste)
    sum=0
    L=[]
    for i in range(len(liste)):
        var=(liste[i]-val)**2
        sum+=var
        L.append(round(liste[i]-val,2))
    var=sum/len(liste)
    return round(var,2),L

  # Utilistion : mettre en parammetre de cette fonction une liste.

##################################################################################################################
########################################################## Ecart type ############################################
##################################################################################################################

###### Je prends en argument une liste de longueur n
###### L'écart type c'est la racine carré de la variance, je prend sqrt(y[0]) car quand je fais la variance, je return la variance ainsi qu'une liste avec chacunes des valeurs
###### intermédiaires du calcul de la variance (car elles sont utiles pour plus tard), je récupère donc juste le coefficient qui se trouve à la position 0 de ma liste.
###### L'écart type c'est la racine de  la variance

def ecarttype(x):
    y=variance(x)
    y=y[0]
    return round(sqrt(y),2)

    # Utilistion : mettre en parammetre de cette fonction une liste.

##################################################################################################################
########################################################## Covariance ############################################
##################################################################################################################

###### Je prends en argument une liste X et une liste Y de longueur n
###### Pour calculer la covariance entre deux listes X et Y, je récupère à l'aide de ma fonction variance() la variance de chacune des listes ainsi que les valeurs issues des
###### calculs intermédiaires dans deux variables -> x1 (variance liste X), x2 (valeurs intermédiaires liste X) et y1 (variance liste Y), y2 (valeurs inermédiaires liste Y)
###### Je parcours les valeurs dans les deux listes et on multiplie les valeurs à la position 0 des deux listes puis on l'ajoute à une variable, on fait ça jusqu'a la fin de la liste
###### on divise par la suite cette variable par la longueur d'une des deux listes.
###### Au début de la fonction, je vérifie bien que les deux listes aient une longueur égale car sinon le calcul n'est pas possible.

def covariance(x,y):
    cov=0
    if len(x) == len(y):
        x1,x2=variance(x)
        y1,y2=variance(y)
        for elements in range(len(x2)):
            cov+=y2[elements]*x2[elements]
        cov=cov/len(x)
        return round(cov,2)
    else:
        print("Une erreur est survenue")

      # Utilistion : mettre en parammetre de cette fonction deux listes.

##################################################################################################################
########################################################## Correlation ###########################################
##################################################################################################################

# je prends en argument deux listes de longueur n
# la corrélation entre deux listes de nombres, c'est la covariance divisée par l'écart-type de la liste 1 fois l'écart-type de la liste 2
# J'arrondi également à deux chiffres après la virgule pour plus de clarté (lib math)

def corre(X,Y):
    value = covariance(X,Y)/(ecarttype(X)*ecarttype(Y))
    return round(value,2)

# Utilistion : mettre en parammetre de cette fonction deux listes.

##################################################################################################################
############################ Histogrammes avec les variances des listes X et Y ###################################
##################################################################################################################

# On prend variance(X)[1] en tant que liste pour l'histogramme car, dans mon return de la fonction variance, je return deux valeurs
# la covariance et les valeurs intermédiaires (sous forme de liste)
# Le print de la variance est de la forme : Variance de la liste X : (47.44, [-8.75, ..., ...]) 47,44 étant la variance et -8,75,... les valeurs

# X est ma liste n°1
# Y est ma liste n°2

def tracerhisto(data,nx="Axe X",ny="Axe Y",titre="Sans titre",col=100,alpha=1,color='Red',grid=True):
    histo.hist(data, bins=col, alpha=1, color=color) # data -> Mon tableau, Bins : la le nombre de "colones", alpha : transparance, red la couleur de l'histogramme
    histo.xlabel(nx)
    histo.ylabel(ny)
    histo.title(titre)
    histo.grid(grid) # Affichage de la grille
    histo.show()

##################################################################################################################
############################ Matrice Correlation #################################################################
##################################################################################################################

# Je prends en argument une liste de liste
# Je crée deux listes vides, subtable et lf, je récupère la  longueur de ma liste de liste et je parcours tous les élements de chacune des listes présentes dans ma grande liste
# (L'argument de ma fonction). Par exemple, je prends la liste A et je calcul la corrélation avec  B puis A avec C puis A avec D ... Jusqu'a A avec N
# Je fais enseuite B avec A, B avec C, B avec D, B avec N
# Ainsi, en théorie on peut calculer la corrélation d'une liste N avec une liste O.

def matricor(liste_a):
    Lf = []
    for i in range(len(liste_a)):
        SubTable = []
        for n in range(len(liste_a)):
            SubTable.append(correlation(liste_a[i], liste_a[n]))
        Lf.append(SubTable)
    return Lf

    # Utilistion : mettre en parammetre de cette fonction une liste contenant tout les lsites que vous voulez traiter

##################################################################################################################
############################ Obtention de nom ####################################################################
##################################################################################################################

# La fonction prend un identifiant (id) en entrée et retourne le nom correspondant à cet identifiant.
# Elle ouvre le fichier namecar.json, le charge en mémoire comme une liste de dictionnaires,
# puis parcourt chaque élément pour trouver celui dont la clé "id" correspond à l'identifiant donné.
# Si une correspondance est trouvée, elle retourne la valeur associée à la clé "name".

def getNameVoiture(id):
        with open("namecar.json", 'r') as file:
            data2 = json.load(file)
        for item in data2:
            if item["id"] == id:
                return item["name"]


def getNameVélo(id):
        with open("namebike.json", 'r') as file:
            data2 = json.load(file)
        for item in data2:
            if item["id"] == id:
                return item["name"]


def getName(id):
    if id.startswith("export"):
        with open("namecar.json", 'r') as file:
            data2 = json.load(file)
        for item in data2:
            if item["id"] == id:
                return item["name"]
    else:
        with open("namebike.json", 'r') as file:
            data2 = json.load(file)
        for item in data2:
            if item["id"] == id:
                return item["name"]
    return id    # Retourne l'ID par défaut si aucun nom n'est trouvé

    # Utilistion : mettre en parammetre de cette fonction le 'entityId' de votre parking

##################################################################################################################
############################ Places moyennes #####################################################################
##################################################################################################################

# La fonction calcule et enregistre la moyenne des places libres pour chaque fichier JSON présent dans un répertoire donné (path).
# Elle parcourt les fichiers du répertoire, vérifie qu'ils respectent un certain format (nom commençant par "export" et se terminant par ".json"),
# puis charge leurs données. Elle extrait les informations sur les places libres "values" et les identifiants temporels "index"
# pour calculer la moyenne avec la fonction "allmoy". Le résultat, accompagné du nom correspondant à l'"entityId"
# (obtenu via la fonction "getName"), est écrit dans un fichier "place.txt".
# Si les longueurs des listes de données sont incohérentes, un message d'avertissement est affiché.

def placemoy(path):
    directory = path
    for nom_fichier in os.listdir(directory):
        if (nom_fichier.startswith("export") or nom_fichier.startswith("tom")) and nom_fichier.endswith(".json"):
            chemin = os.path.join(directory, nom_fichier)

            with open(chemin, 'r') as file:
                data = json.load(file)

            place = data["values"]
            ids = data["index"]
            entity_name = getName(data["entityId"])

            with open("place.txt", 'a') as f:
                f.write(f'{entity_name} : {allmoy(place)} places libres en moyenne.\n')

            if len(place) != len(ids):
                print(f"Attention : les longueurs de 'values' et 'index' dans {nom_fichier} ne correspondent pas.")
                continue

      # Utilistion : mettre en parammetre de cette fonction le chemin d'accès vers un fichier, un dossier ou un repertoire
      # ou se trouve les fichiers que vous voulez traiter.
      # Il faut aussi changer la ligne "if" en changeant les conditions : pour nous, les fichiers commencaient par tom ou export.

##################################################################################################################
############################ Formatage de 4 semaines en 1 mois (vélo) ############################################
##################################################################################################################

    # Cette fonction traite les fichiers JSON du répertoire donné pour extraire et reformater les données.
    # "directory" est le chemin d'accés du répertoire contenant les fichiers JSON à traiter.
    # La fonction parcourt tous les fichiers dans le répertoire spécifié.
    # Elle ne traite que les fichiers dont le nom commence par "export_bike" et se termine par ".json".
    # Pour chaque fichier, elle extrait le nombre de places libres, les heures de captures et les identifiants des parking (s'ils existent).
    # Les données extraites sont organisées dans des dictionnaires en fonction d'un identifiant 'x' extrait du nom du fichier.
    # Elle crée de nouveaux fichiers JSON avec les données reformées et les enregistre dans le même répertoire avec un nouveau nom de fichier.

def Formatage(directory) :
    values_by_x = {}
    values_by_y = {}
    extra_var_by_x = {}

    for nom_fichier in os.listdir(directory):
        if nom_fichier.startswith("export_bike") and nom_fichier.endswith(".json"):
            chemin = os.path.join(directory, nom_fichier)

            parts = nom_fichier.split('_')
            if len(parts) >= 3:
                x = parts[2]

                with open(chemin, 'r') as file:
                    data = json.load(file)

                if "values" in data:
                    if x not in values_by_x:
                        values_by_x[x] = []
                    values_by_x[x].extend(data["values"])
                else:
                    print(f"'values' non trouvé dans {nom_fichier}")

                if "index" in data:
                    if x not in values_by_y:
                        values_by_y[x] = []
                    values_by_y[x].extend(data["index"])
                else:
                    print(f"'index' non trouvé dans {nom_fichier}")

                if "entityId" in data:
                    if x not in extra_var_by_x:
                        extra_var_by_x[x] = str(data["entityId"])
                    else:
                        extra_var_by_x[x] += f", {data['entityId']}"

    for x in values_by_x.keys():
        file_path = 'tom' + x + '.json'
        file_data = {
            "values": values_by_x.get(x, {}),
            "index": values_by_y.get(x, {}),
            "entityId": extra_var_by_x.get(x)
        }
        with open(file_path, "w") as f:
            json.dump(file_data, f, indent=4)


      # Utilistion : mettre en parammetre de cette fonction le chemin d'accès vers un fichier, un dossier ou un repertoire
      # ou se trouve les fichiers que vous voulez traiter.
      # Il faut aussi changer la  1er ligne "if" en changeant les conditions : pour nous, les fichiers commencaient par export_bike.

##################################################################################################################
############################ Graph vélo ##########################################################################
##################################################################################################################


    # La fonction génère des graphiques interactifs montrant le nombre de places de parking pour vélos disponibles au fil du temps.
    # "directory" est le chemin d'accés du répertoire contenant les fichiers JSON à traiter.
    # La fonction parcourt tous les fichiers dans le répertoire spécifié.
    # Elle ne traite que les fichiers dont le nom commence par "tom" et se termine par ".json".
    # Pour tous fichier, on vient extraire le nombre de places libres et les moments des captures et le ID des parkings
    # Elle vérifie que les longueurs des listes 'values' et 'index' correspondent.
    # Elle crée un graphique interactif en utilisant Plotly, montrant le nombre de places libres en fonction du temps.
    # Le graphique est enregistré en tant que fichier HTML dans le même répertoire avec un nom de fichier basé sur l'identifiant d'entité.
    # Note : Pour avoir des résultat pour une durée plus courte, il suffit de mettre le nombre de ligne que vous voulez traiter du fichier JSON sous la forme :
    # Ex : place = data["values"][:xxx]

def velo_Graph(directory) :

    place = []

    for nom_fichier in os.listdir(directory):
        if nom_fichier.startswith("tom") and nom_fichier.endswith(".json"):
            chemin = os.path.join(directory, nom_fichier)

            with open(chemin, 'r') as file:
                data = json.load(file)

            place = data["values"][:9999]
            ids = data["index"][:9999]

            if len(place) != len(ids):
                print(f"Attention : les longueurs de 'values' et 'index' dans {nom_fichier} ne correspondent pas.")
                continue

            fig = go.Figure()
            fig.add_trace(go.Scatter(
                x=ids,
                y=place,
                mode='lines+markers',
                name='Places libres',
                text=[f'({id}, {pl})' for id, pl in zip(ids, place)],
                hoverinfo='text'
            ))

            fig.update_layout(
                    title=f'Nombre de places libres, Parking : {getNameVélo(data["entityId"])}',
                    xaxis_title='Temps',
                    yaxis_title='Places libres'
                )


            output_nom_fichier = f'graphique_Vélo_{getNameVélo(data["entityId"])}.html'
            pio.write_html(fig, os.path.join(directory, output_nom_fichier))

      # Utilistion : mettre en parammetre de cette fonction le chemin d'accès vers un fichier, un dossier ou un repertoire
      # ou se trouve les fichiers que vous voulez traiter.
      # Il faut aussi changer la ligne "if" en changeant les conditions : pour nous, les fichiers commencaient par tom.

##################################################################################################################
############################ Graph Voiture #######################################################################
##################################################################################################################

    # Idem.

def Graph_voiture(directory) :

    place = []

    for nom_fichier in os.listdir(directory):
        if nom_fichier.startswith("export") and nom_fichier.endswith(".json"):
            filepath = os.path.join(directory, nom_fichier)

            with open(filepath, 'r') as file:
                data = json.load(file)

            place = data["values"][:2015]
            ids = data["index"][:2015]

            if len(place) != len(ids):
                print(f"Attention : les longueurs de 'values' et 'index' dans {nom_fichier} ne correspondent pas.")
                continue

            fig = go.Figure()
            fig.add_trace(go.Scatter(
                x=ids,
                y=place,
                mode='lines+markers',
                name='Places libres',
                text=[f'({id}, {pl})' for id, pl in zip(ids, place)],
                hoverinfo='text'
            ))

            fig.update_layout(
                    title=f'Nombre de places libres, Parking : {getNameVoiture(data["entityId"])}',
                    xaxis_title='Temps',
                    yaxis_title='Places libres'
                )


            output_nom_fichier = f'graphique_Voiture_{getNameVoiture(data["entityId"])}.html'
            pio.write_html(fig, os.path.join(directory, output_nom_fichier))

      # Utilistion : mettre en parammetre de cette fonction le chemin d'accès vers un fichier, un dossier ou un repertoire
      # ou se trouve les fichiers que vous voulez traiter.
      # Il faut aussi changer la ligne "if" en changeant les conditions : pour nous, les fichiers commencaient par export.


##################################################################################################################
############################ Heatmap #############################################################################
##################################################################################################################

    # La fonction utilise la bibliothèque matplotlib pour créer une figure
    # Elle utilise la bibliothèque seaborn pour générer une heatmap de la matrice de corrélation.
    # La heatmap est annotée avec les valeurs de corrélation, utilise une palette de couleurs 'coolwarm', et affiche les valeurs avec deux décimales.
    # Un titre est ajouté à la heatmap pour indiquer qu'il s'agit de la matrice de corrélation.
    # La heatmap est affichée à l'écran.

def afficher_heatmap(matrice):
    plt.figure(figsize=(8, 6))
    sns.heatmap(matrice, annot=True, cmap='coolwarm', fmt=".2f", linewidths=0.5)
    plt.title("Heatmap de la matrice de corrélation")
    plt.show()

      # Utilistion : mettre en parammetre de cette fonction une matrice de corrélation

##################################################################################################################
############################ Heatmap avec nom de tout le fichier #################################################
##################################################################################################################

    # "directory" est le chemin d'accés du répertoire contenant les fichiers JSON à traiter.
    # La fonction initialise des listes pour stocker les données des parkings de vélos et de voitures ainsi que leurs identifiants.
    # Elle parcourt tous les fichiers dans le répertoire
    # Pour chaque fichier JSON, elle vérifie s'il commence par "tom" (parkings de vélos) ou "export" (parkings de voitures) et extrait les données correspondantes.
    # Elle calcule les matrices de corrélation pour les données des parkings de vélos et de voitures.
    # Elle affiche des heatmaps pour les matrices de corrélation en utilisant les identifiants des parkings pour les étiquettes.

    # Ci-dessous des variantes de certaines fonctions existantes, modifié pour faire marcher cette fonction

#############
def matricore(liste_a):
    Lf = []
    for i in range(len(liste_a)):
        SubTable = []
        for n in range(len(liste_a)):
            SubTable.append(correlation(liste_a[i], liste_a[n]))
        Lf.append(SubTable)
    return np.array(Lf)
def correlation(liste_a, liste_b):
    return pearsonr(liste_a, liste_b)[0]
#############


def heat(directory):

    place = []
    ids = []

    # Parcours des fichiers dans le répertoire
    for nom_fichier in os.listdir(directory):
        if (nom_fichier.startswith("export") or nom_fichier.startswith("tom")) and nom_fichier.endswith(".json"):
            filepath = os.path.join(directory, nom_fichier)

            # Lecture et traitement du fichier JSON
            with open(filepath, 'r', encoding='utf-8') as file:
                data = json.load(file)
                place.append(data["values"])
                ids.append(data["entityId"])

    # Traitement des données si des données valides sont trouvées
    if place:
        matrice_correlation = matricore(place)  # Fonction matricore (supposée existante)
        matrice_inversee = np.flipud(np.fliplr(matrice_correlation))  # Inversion de la matrice
        names = [getName(id) for id in ids]  # Récupération des noms associés aux IDs
        df = pd.DataFrame(matrice_inversee, index=names, columns=names)

        # Génération de la heatmap
        fig = px.imshow(df, text_auto=True, color_continuous_scale='RdBu_r', title="Heatmap de la matrice de corrélation")
        fig.show()
    else:
        print("Aucune donnée trouvée.")

      # Utilistion : mettre en parammetre de cette fonction le chemin d'accès vers un fichier, un dossier ou un repertoire
      # ou se trouve les fichiers que vous voulez traiter.
      # Il faut aussi changer la ligne "if" en changeant les conditions : pour nous, les fichiers commencaient par tom ou export.

####################################################################################################################################

import requests
import json
import datetime as date

# cdate = date.datetime.now().strftime("%Y-%m-%d-%H-%M-%S") # https://www.programiz.com/python-programming/datetime/strftime
# Nous prenons en argument le type de parking (car ou bike), le lien souhaité pour l'export (uniquement pour les vélos)
# le numéro à rajouter dans le nom du fichier (n) et l'indentation (indent).

#Afin de récupérer pour tous les parkings, on change le numéro du parking présent dans le lien, on le remplace par i (le numéro du parking).
def getAllParkData(type,link,n,indent=4):
    if type == "car":
        for i in range(1,26): # Jusqu'a 26 car il y à 25 parkings voiture à Montpellier
            Liens = "https://portail-api-data.montpellier3m.fr/parking_timeseries/urn%3Angsi-ld%3Aparking%3A001/attrs/availableSpotNumber?fromDate=2024-12-17T00%3A00%3A00&toDate=2025-01-16T00%3A00%3A00"
            if i < 10:
                Liens = list(Liens) # On transforme la chaine de caractère en liste pour pouvoir modifier les valeurs
                Liens[89]=f"{i}" # On remplace la valeur 89 de la liste par i (le numéro du parking), exemple : : exemple -> Angsi-ld%3Aparking%3A001 -> Angsi-ld%3Aparking%3:A00i
                Liens = ''.join(Liens) # On join le tout pour reconstruire le lien
            else:
                a = str(i)
                Liens = list(Liens) # On transforme la chaine de caractère en liste pour pouvoir modifier les valeurs
                Liens[89]=f"{int(a[1])}" # Contrairement à avant, on a deux digits à remplacer, il faut donc prendre
                # deux valeurs de la liste et les remplacer
                Liens[88]=f"{int(a[0])}"
                # exemple : : exemple -> Angsi-ld%3Aparking%3A001 -> Angsi-ld%3Aparking%3:A0i (on remplace les deux derniers digits car i est supérieur à 10)
                Liens = ''.join(Liens)
            response=requests.get(Liens)
            data = response.json() # Convertir en json
            file = open(f"export_car_{i}.json","w") # On crée un fichier export avec le numéro du parking.
            file.write(json.dumps(data, indent=indent)) # utilisation de json.dumps pour transformer la liste en contenu json avec une indentation de 4 (déclage)
            file.close()
    elif type == "bike":
        for i in range(1,62): # 61 Parkings vélos, on prends 62 pour éviter les erreurs
            # Liens = "https://portail-api-data.montpellier3m.fr/bikestation_timeseries/urn%3Angsi-ld%3Astation%3A001/attrs/availableBikeNumber?fromDate=2024-12-16T00%3A00%3A00&toDate=2025-01-16T00%3A00%3A00"
            Liens = link
            if i < 10: # Idem quer pour les voitures, on modifie le lien pour chaque parking si i < 10 on modifie un seul digit Exemple : : exemple : urn%3Angsi-ld%3Astation%3A001 -> urn%3Angsi-ld%3Astation%3:A00i
                Liens = list(Liens)
                Liens[93]=f"{i}" # Le caractère à remplacer est à la place 93
                Liens = ''.join(Liens) #Reconstruction du lien
                print(Liens)
            else:
                a = str(i)
                Liens = list(Liens) # Idem que plus haut mais i > 10 donc I fait deux digits, il faut donc remplacer deux endroits de la liste, ici  93 et 92
                Liens[93]=f"{int(a[1])}"
                Liens[92]=f"{int(a[0])}" # résultat : urn%3Angsi-ld%3Astation%3:A0i (on remplace les deux derniers digits car i est supérieur à 10)
                Liens = ''.join(Liens)
                print(Liens)

            response=requests.get(Liens)
            data = response.json() # Convertir en json
            file = open(f"export_bike_{i}_{n}.json","w")
            file.write(json.dumps(data, indent=indent)) # utilisation de json.dumps pour transformer la liste en contenu json avec une indentation de 4 (déclage)
            file.close()

# On fait une requête get sur l'API, on récupère les données en json, on crée un fichier export.json et on écrit les données dans ce fichier.
# La fonction prend en argument l'agument agr qui permet de print ou non un message de confirmation (succès ou non de l'export) et l'indentation souhaité qui est par défaut à 4
def getCarParkData(agr,indent=4):
    try:
        response=requests.get("https://portail-api-data.montpellier3m.fr/offstreetparking?limit=1000")
        data = response.json() # Convertir en json
        file = open(f"export.json","w")
        file.write(json.dumps(data, indent=indent)) # utilisation de json.dumps pour transformer la liste en contenu json avec une indentation de 4 (déclage)
        file.close()
        if agr == "print":
            print(f"New file exported : export.json (car)")
        else:
            pass
    except:
        print(f"An error has occurred -> data.py") #Pour le debug

# Identique que pour les voitures seulement on change le lien pour les vélos.

def getBikeParkData(agr,indent=4):
    try:
        response=requests.get("https://portail-api-data.montpellier3m.fr/bikestation?limit=1000")
        data = response.json() # Convertir en json
        file = open(f"exportbike.json","w")
        file.write(json.dumps(data, indent=indent)) # utilisation de json.dumps pour transformer la liste en contenu json avec une indentation de 4 (déclage)
        file.close()
        if agr == "print":
            print(f"New file exported : exportbike.json")
        else:
            pass
    except:
        print(f"An error has occurred -> data.py (bike)") #debug

import json
import time
from math import *

# Définition de variables qui sont utilisées dans les fonctions pour générer la map
mysave = "export.json"
mysavebike = "exportbike.json"

# Ecrire les données dans un fichier (pas utilisé dans le programme mais présent pour des tests)
def writeData(data,namefile):
    file = open(namefile,"w")
    file.write(data)
    file.close()

# Récupérer les données d'un fichier json
def getData(namefile):
    file = open(namefile,"r")
    data = json.load(file)
    return data

# Récupérer les données de tous les parkings (voitures et vélo)
# Récupérer l'heure de du dernier enregistrement, (utilisé pour l'affichage sur la map)
def getHour(namesave,id):
    data = getData(namesave) # -> Récupération des données dans mon fichier export.json issu de l'API
    if namesave == mysavebike: # -> SI fichier export (voiture)
        h = data[id]["availableBikeNumber"]["metadata"]["timestamp"]["value"] # -> Récupération de l'heure de l'enregistrement
        h=h.split("T") # On fait un split T et on obtient : h=[2024-12-16,13:12:10.000Z]
        h[1]=h[1][0:8] # On rogne l'heure et on obtient : h=[2024-12-16,13:12:10]
        date = str(h[0]) # Conversion en chaine de caractère utile pour faire l'étape d'après
        date = date.split("-") # split - qui donne : date=[2024,12,16]
        date.reverse() # On inverse la liste pour avoir : date=[16,12,2024] et mettre la date au format françaiss
        date = "-".join(date) # On join la liste pour avoir : date=16-12-2024
        h[0]=date #  on enregistre le tout
        return h[0]+" à "+h[1] # Résultat que l'on return : 16-12-2024 à 13:12:10
    else:
        h = data[id]["status"]["metadata"]["timestamp"]["value"] # -> Récupération de l'heure de l'enregistrement des données (cette fois pour les vélos, la syntaxe du JSON est différete)
        h=h.split("T") # Split en T pour obtenir : h=[2024-12-16,13:12:10.000Z]
        h[1]=h[1][0:8] # On rogne l'heure et on obtient : h=[2024-12-16,13:12:10]
        date = str(h[0]) # Conversion en chaine de caractère utile pour faire l'étape d'après
        date = date.split("-") # split - qui donne : date=[2024,12,16]
        date.reverse() # On inverse la liste pour avoir : date=[16,12,2024] et mettre la date au format françaiss
        date = "-".join(date) # On join la liste pour avoir : date=16-12-2024
        h[0]=date # on enregistre le tout
        return h[0]+" à "+h[1] # Idem que pour les voitures, on return le résultat : 16-12-2024 à 13:12:10

# On prend en argument le nom du fichier et l'id du parking
def getparkname(namesave,id):
    data = getData(namesave)
    if namesave == mysavebike:
        return data[id]["address"]["value"]["streetAddress"]+" - "+data[id]["address"]["value"]["addressLocality"]
        # On return le nom du parking (vélo)
    else:
        return data[id]["name"]["value"]
        # On return le nom du parking (voiture)

#Fonction qui détermine le type de parking, si c'est un parking vélo ou voiture (inutile dans le programme mais présent pour des tests)
# On prend en argument le nom du fichier et l'id du parking
def getParkType(namesave,id):
    try:
        data = getData(namesave)
        if data[id]["type"] == "BikeHireDockingStation":
            return "bike"
        elif data[id]["type"] == "OffStreetParking":
            return "car"
    except:
        print(f"An error has occurred : script.py/getParkState")


# Récupérer l'état du parking (plein ou non)
# On prend en argument le nom du fichie et l'id du parking
def getParkState(nameSave,id):
    try:
        data = getData(nameSave) # Récupération des données
        # Pour les voitures
        if nameSave == mysave: # SI c'est un parking voiture
            if data[id]["status"]["value"] == "Open":
                return True # Open -> Parking ouvert -> True
            elif data[id]["status"]["value"] == "Full":
                return True # Open quand même mais full
        # Pour les vélos
        elif nameSave == mysavebike: # SI c'est un parking vélo
            if data[id]["status"]["value"] == "working": # working -> Parking ouvert -> True
                return True
            else:
                return False
    except:
        print(f"An error has occurred : script.py/getParkState") # Debug

# Voiture
# On prend en argument le nom du fichier et l'id du parking
def getPlacesLibres(nameSave,id):
    try:
        data = getData(nameSave) # On récupère les données
        if getParkState(mysave,id):
            if data[id]["availableSpotNumber"]["value"] == 0:
                # Calcul de l'occupation du parking
                return [{"statepark":"Open","namepark":data[id]["id"],"placeslibres":data[id]["availableSpotNumber"]["value"],"placestotales":data[id]["totalSpotNumber"]["value"],"occupation":100}]
            else:
                # Calcul de l'occupation du parking
                return [{"statepark":"Open","namepark":data[id]["id"],"placeslibres":data[id]["availableSpotNumber"]["value"],"placestotales":data[id]["totalSpotNumber"]["value"],"occupation":round((100*(data[id]["totalSpotNumber"]["value"]-data[id]["availableSpotNumber"]["value"])/data[id]["totalSpotNumber"]["value"]),2)}]
        else:
            # SI le parking est fermé
            return [{"statepark":"Closed"}]
    except:
        print(f"An error has occurred : script.py/getPlacesLibres") # Debug


# Voiture et Vélo
# On prend en argument le nom du fichier et l'id du parking
def getParkCoords(nameSave,id):
    try:
        data = getData(nameSave) # On récupère les données
        return data[id]["location"]["value"]["coordinates"] # On return les coordonés GPS du parking
    except:
        print(f"An error has occurred : script.py/getParkCoords") #Debug


# Voiture et Vélo

def getPlacesLibresPercent(nameSave,id):
    data = getData(nameSave) # -> Récupération des données
    if nameSave == mysave: #Parking voiture
        if getParkState(nameSave,id): #Si le parking est ouvert
            # Calcul du pourcentage de places libres
            percent = (100*data[id]["availableSpotNumber"]["value"]/data[id]["totalSpotNumber"]["value"])
        return [data[id]["name"]["value"],round(percent,2)] #On return le résultat
    elif  nameSave == mysavebike: # Parking vélo
        if getParkState(nameSave,id): # Si le parking est ouvert
            percent = 100-(100*data[id]["freeSlotNumber"]["value"]/data[id]["totalSlotNumber"]["value"])
        return  [data[id]["address"]["value"]["streetAddress"],round(percent,2),data[id]["freeSlotNumber"]["value"],data[id]["totalSlotNumber"]["value"]]
        # On return le nom du parking, le pourcentage de vélo libres, les places libres, les places totales

# Voiture et Vélo

# On prend en argument le nom du fichier, la période d'échantillonage et la durée de l'échantillonage
def getPlacesLibresDuree(nameSave,Te,Duree):
    try:
        getCarParkData("noprint",4) # On récupère les données avec 4 en indentation, sans print
        prev = int(time.time()) # On récupère le temps actuel
        previ = int(time.time()) # On récupère le temps actuel
        data = getData(nameSave) # On récupère les données
        while int(time.time())-previ < Duree*60: # Chronomètre
            if int(time.time())-prev > Te: # Echantillonage
                file2 = open("placevoiture.txt","a") #Fichier voituire
                file3 = open("placesvelo.txt","a")  # Fichier vélo
                for id in range(len(data)):
                    if nameSave == mysave: # Si c'est un parking voiture
                        if getParkState(mysave,id): # Si le parking est ouvert
                            file2.write(f'[{{"namePark": "{data[id]["name"]["value"]}","state":"open","parktype":"car","date": "{data[id]["availableSpotNumber"]["metadata"]["timestamp"]["value"]}", "placeslibres": {data[id]["availableSpotNumber"]["value"]}}}]\n')
                            # On écrit dans le fichier les données
                    elif nameSave == mysavebike: #SI c'est des vélos
                        if getParkState(mysavebike,id):  # Si c'est ouvert
                            file3.write(f'[{{"namePark": "{getparkname(mysavebike,id)}","state":"open","parktype":"bike","date": "{data[id]["availableBikeNumber"]["metadata"]["timestamp"]["value"]}", "placeslibres": {data[id]["freeSlotNumber"]["value"]}}}]\n')
                # Ecriture puis fermeture des fichiers
                file3.close()
                file2.close()
                prev=int(time.time()) # Mise à jour du chrono
    except:
        print(f"An error has occured : script.py/getPlacesLibresDuree") #Debug

# Générer un table avec les noms des parkings en fonction des id et y mettre les places totales
# pour la génération de graphiques. On prend en argument le nom du fichier qui contient la save de l'API

def parkTable(namesave):
    data = getData(namesave)
    file2 = open("table.json","w") #Création du fichier
    L=[]
    for id in range(len(data)):
        item = {
            "name": data[id]["name"]["value"],
            "id": data[id]["id"],
            "placexmax": data[id]["totalSpotNumber"]["value"]
        }
        L.append(item) # On ajoute dans la liste le nom, l'id et le nombre de places totales du export.json
    file2.write(json.dumps(L, indent=4)) # On écrit au format json pour faciliter la ré utilisation pluis tard
    file2.close()

# parkTable("export.json")

# Idem que la fonction ci-dessus mais c'est pour les vélos, quelques champs changent
def parkBikeTable(namesave):
    data = getData(namesave)
    file2 = open("tablebike.json","w")
    L=[]
    for id in range(len(data)):
        item = {
            "name": data[id]["address"]["value"]["streetAddress"],
            "id": data[id]["id"],
            "placexmax": data[id]["totalSlotNumber"]["value"]
        }
        L.append(item)
    file2.write(json.dumps(L, indent=4))
    file2.close()

# parkBikeTable("exportbike.json")



import time

import folium
import webbrowser
import os
import datetime as date

# ⎽⎼⎻⎺⎺⎻⎼⎽⎽⎼⎻⎺⎺⎻⎼⎽⎽⎼⎻⎺⎺⎻⎼⎽⎽⎼⎻⎺⎺⎻⎼⎽⎽⎼⎻⎺⎺⎻⎼⎽⎽⎼⎻⎺⎺⎻⎼⎽⎽⎼⎻⎺⎺⎻⎼⎽⎽⎼⎻⎺⎺⎻⎼⎽⎽⎼⎻⎺⎺⎻⎼⎽⎽⎼⎻⎺⎺⎻⎼⎽⎽⎼⎻⎺⎺⎻⎼⎽⎽⎼⎻⎺⎺⎻⎼⎽⎽⎼⎻⎺⎺⎻⎼⎽⎽⎼⎻⎺⎺⎻⎼⎽⎽⎼⎻⎺⎺⎻⎼⎽⎽⎼⎻⎺⎺⎻⎼⎽
# ⎽⎼⎻⎺⎺⎻⎼⎽⎽⎼⎻⎺⎺⎻⎼⎽⎽⎼⎻⎺⎺⎻⎼⎽⎽⎼⎻⎺⎺⎻⎼⎽⎽⎼⎻⎺ Made by Valentin MALOT & Romain CASTELLI ⎺⎻⎼⎽⎽⎼⎻⎺⎺⎻⎼⎽⎽⎼⎻⎺⎺⎻⎼⎽⎽⎼⎻⎺⎺⎻⎼⎽⎽⎼⎻⎺⎺⎻⎼⎽⎽⎼⎻⎺⎺⎻⎼⎽⎽⎼⎻⎺⎺
# ⎽⎼⎻⎺⎺⎻⎼⎽⎽⎼⎻⎺⎺⎻⎼⎽⎽⎼⎻⎺⎺⎻⎼⎽⎽⎼⎻⎺⎺⎻⎼⎽⎽⎼⎻⎺        10/01/2025 - SAE 1.5              ⎺⎻⎼⎽⎽⎼⎻⎺⎺⎻⎼⎽⎽⎼⎻⎺⎺⎻⎼⎽⎽⎼⎻⎺⎺⎻⎼⎽⎽⎼⎻⎺⎺⎻⎼⎽⎽⎼⎻⎺⎺⎻⎼⎽⎽⎼⎻⎺⎺
# ⎽⎼⎻⎺⎺⎻⎼⎽⎽⎼⎻⎺⎺⎻⎼⎽⎽⎼⎻⎺⎺⎻⎼⎽⎽⎼⎻⎺⎺⎻⎼⎽⎽⎼⎻⎺⎺⎻⎼⎽⎽⎼⎻⎺⎺⎻⎼⎽⎽⎼⎻⎺⎺⎻⎼⎽⎽⎼⎻⎺⎺⎻⎼⎽⎽⎼⎻⎺⎺⎻⎼⎽⎽⎼⎻⎺⎺⎻⎼⎽⎽⎼⎻⎺⎺⎻⎼⎽⎽⎼⎻⎺⎺⎻⎼⎽⎽⎼⎻⎺⎺⎻⎼⎽⎽⎼⎻⎺⎺⎻⎼⎽⎽⎼⎻⎺⎺⎻⎼⎽⎽⎼⎻⎺⎺⎻⎼⎽

def generateMap(WithOrNot,open=True):
    lat, lon = 43.6113889, 3.8708334 # Coordonés du centre de Montpellier
    cdate = date.datetime.now().strftime("%d_%m_%Y_%H-%M-%S") # https://www.programiz.com/python-programming/datetime/strftime
    map = folium.Map(location=[lat, lon], tiles="OpenStreetMap", zoom_start=12) # Création de la map
    # Documentation : https://python-visualization.github.io/folium/latest/user_guide/map.html
    if WithOrNot == "without": # Si on veut ou pas les icones customs
########################### VERSION SANS LES ICONES CUSTOMISES ####################################################################################################
        getCarParkData(4) # Création du fichier export.json
        data = getData(mysave) # récupération des data
        for points in range(len(data)):
            # Les blocs if ci-dessous permettent de voir si le taux d'occupation est supérieur à une certaine valeur
            # 100, 95, 90, 70, 50, 0 et adapter la couleur du marqueur sur la carte.

            # C'est le premier prototype que nous avons fait, nous vous conseillons de mettre les icones car c'est mieux
            # fini, les popups sont faites en html (c'est plus propre).
            if getPlacesLibres(mysave,points)[0]["occupation"] == 100:
                folium.Marker(
                    location=[getParkCoords(mysave,points)[1], getParkCoords(mysave,points)[0]],
                    popup=f'Parking : {getparkname(mysave,points)}, Places libres : {getPlacesLibres(mysave,points)[0]["placeslibres"]}/{getPlacesLibres(mysave,points)[0]["placestotales"]} - Occupation : {getPlacesLibres(mysave,points)[0]["occupation"]}% à {data[points]["availableSpotNumber"]["metadata"]["timestamp"]["value"]} ',
                    icon=folium.Icon(color='black')  # Noir
                ).add_to(map)
            elif getPlacesLibres(mysave,points)[0]["occupation"] > 95:
                folium.Marker(
                    location=[getParkCoords(mysave,points)[1], getParkCoords(mysave,points)[0]],
                    popup=f'Parking : {getparkname(mysave,points)}, Places libres : {getPlacesLibres(mysave,points)[0]["placeslibres"]}/{getPlacesLibres(mysave,points)[0]["placestotales"]} - Occupation : {getPlacesLibres(mysave,points)[0]["occupation"]}% à {data[points]["availableSpotNumber"]["metadata"]["timestamp"]["value"]} ',
                    icon=folium.Icon(color='darkpurple') # Violet
                ).add_to(map)
            elif getPlacesLibres(mysave,points)[0]["occupation"] > 90:
                folium.Marker(
                    location=[getParkCoords(mysave,points)[1], getParkCoords(mysave,points)[0]],
                    popup=f'Parking : {getparkname(mysave,points)}, Places libres : {getPlacesLibres(mysave,points)[0]["placeslibres"]}/{getPlacesLibres(mysave,points)[0]["placestotales"]} - Occupation : {getPlacesLibres(mysave,points)[0]["occupation"]}% à {data[points]["availableSpotNumber"]["metadata"]["timestamp"]["value"]} ',
                    icon=folium.Icon(color='darkred') # Rouge foncé
                ).add_to(map)
            elif getPlacesLibres(mysave,points)[0]["occupation"] > 70:
                folium.Marker(
                    location=[getParkCoords(mysave,points)[1], getParkCoords(mysave,points)[0]],
                    popup=f'Parking : {getparkname(mysave,points)}, Places libres : {getPlacesLibres(mysave,points)[0]["placeslibres"]}/{getPlacesLibres(mysave,points)[0]["placestotales"] } - Occupation : {getPlacesLibres(mysave,points)[0]["occupation"]}% à {data[points]["availableSpotNumber"]["metadata"]["timestamp"]["value"]} ',
                    icon=folium.Icon(color='red') # Rouge
                ).add_to(map)
            elif getPlacesLibres(mysave,points)[0]["occupation"] > 50:
                folium.Marker(
                    location=[getParkCoords(mysave,points)[1], getParkCoords(mysave,points)[0]],
                    popup=f'Parking : {getparkname(mysave,points)}, Places libres :  {getPlacesLibres(mysave,points)[0]["placeslibres"]}/{getPlacesLibres(mysave,points)[0]["placestotales"]} - Occupation : {getPlacesLibres(mysave,points)[0]["occupation"]}% à {data[points]["availableSpotNumber"]["metadata"]["timestamp"]["value"]} ',
                    icon=folium.Icon(color='orange') # Orange
                ).add_to(map)
            else:
                folium.Marker(
                    location=[getParkCoords(mysave,points)[1], getParkCoords(mysave,points)[0]],
                    popup=f'Parking : {getparkname(mysave,points)}, Places disponibles :  {getPlacesLibres(mysave,points)[0]["placeslibres"]}/{getPlacesLibres(mysave,points)[0]["placestotales"]} - Occupation : {getPlacesLibres(mysave,points)[0]["occupation"]}% à {data[points]["availableSpotNumber"]["metadata"]["timestamp"]["value"]} ',
                    icon=folium.Icon(color='green') # Vert
                ).add_to(map)
    elif WithOrNot == "with":
########################## AVEC Icones : ##############################################################################################################
        getCarParkData(4) # création du export.json
        data = getData(mysave) # Récupération des données
        for points in range(len(data)):
            # Popup faite en html avec un titre h3 et du texte p. Tout ça est placé dans une div et contient les valeurs
            # calculées à l'aie de nos fonctions
            htmlcar = f'''
                <div style="width:450px;">
                    <h3>Parking : {getparkname(mysave,points)}</h3>
                    <p style="margin: 5px 0;">Places libres : {getPlacesLibres(mysave,points)[0]["placeslibres"]}/{getPlacesLibres(mysave,points)[0]["placestotales"]}</p>
                    <p style="margin: 5px 0;">Occupation : {getPlacesLibres(mysave,points)[0]["occupation"]} % </p>
                    <p style="margin: 5px 0;">Date : {getHour(mysave,points)}</p>
                </div>
            '''
            # Création du marker avec la popup, les coordonés GPS et l'icone customisée.
            folium.Marker(
                location=[getParkCoords(mysave,points)[1], getParkCoords(mysave,points)[0]], #getParkCoords fonction expliquée plus haut
                popup=folium.Popup(htmlcar, max_width=300),
                icon=folium.CustomIcon(icon_image="emplacement.png",  icon_size=(40, 40))
            ).add_to(map)
################## VELO MAP ##############################################################################################################################
    getBikeParkData(4) # création de exportbike.json
    data = getData("exportbike.json") # Récupération des données
    for points in range(len(data)):
        # Création de la popup à l'aide des fonctions dans une div html avec un titre h3 et du texte p
        htmlvélo = f'''
            <div style="width:450px;">
                <h3>Parking : {getparkname(mysavebike, points)}</h3>
                <p style="margin: 5px 0;">Vélos disponibles : {getPlacesLibresPercent(mysavebike, points)[3] - getPlacesLibresPercent(mysavebike, points)[2]}/{getPlacesLibresPercent(mysavebike, points)[3]} </p>
                <p style="margin: 5px 0;">Emplacements libres : {getPlacesLibresPercent(mysavebike, points)[2]}/{getPlacesLibresPercent(mysavebike, points)[3]}</p>
                <p style="margin: 5px 0;">Occupation des emplacements : {getPlacesLibresPercent(mysavebike, points)[1]} % </p>
                <p style="margin: 5px 0;">Date : {getHour(mysavebike,points)}</p>
            </div>
        '''
        folium.Marker(
            location=[getParkCoords(mysavebike, points)[1], getParkCoords(mysavebike, points)[0]],
            popup=folium.Popup(htmlvélo, max_width=300),
            # popup=f"Parking Vélo : {getparkname(mysavebike, points)}, Vélos disponibles : {getPlacesLibresPercent(mysavebike, points)[3] - getPlacesLibresPercent(mysavebike, points)[2]}/{getPlacesLibresPercent(mysavebike, points)[3]}, Emplacements libres {getPlacesLibresPercent(mysavebike, points)[2]}/{getPlacesLibresPercent(mysavebike, points)[3]} : Occupation des emplacements: {getPlacesLibresPercent(mysavebike, points)[1]} % ",
            icon=folium.CustomIcon(icon_image="velo.png", icon_size=(35, 35))
        ).add_to(map)
        # Sauvegarder la map avec la date d'aujourd'hui et l'heure actuelle
    map.save(f"Montpellier-{cdate}.html")
    if open == True:
        # Ouvrir dans le navigateur la page générée
        webbrowser.open('file://' + os.path.realpath(f"Montpellier-{cdate}.html"), new=2)
    else:
        pass


###################### MAP  ##################################

# Générer la map avec les icones customisées (With) sinon sans les icones customisées (without)
generateMap("with",True)

###################### DATA VELOS ##################################

# Récupération de toutes les données pour 1 mois des parkings vélo (ne pas activer sinon beaucoup de fichiers vont être générés !!!)
# link1 = "https://portail-api-data.montpellier3m.fr/bikestation_timeseries/urn%3Angsi-ld%3Astation%3A001/attrs/availableBikeNumber?fromDate=2024-12-16T00%3A00%3A00&toDate=2024-12-23T23%3A59%3A59"
# link2= "https://portail-api-data.montpellier3m.fr/bikestation_timeseries/urn%3Angsi-ld%3Astation%3A001/attrs/availableBikeNumber?fromDate=2024-12-23T00%3A00%3A00&toDate=2024-12-30T23%3A59%3A59"
# link3= "https://portail-api-data.montpellier3m.fr/bikestation_timeseries/urn%3Angsi-ld%3Astation%3A001/attrs/availableBikeNumber?fromDate=2024-12-30T00%3A00%3A00&toDate=2025-01-06T23%3A59%3A59"
# link4= "https://portail-api-data.montpellier3m.fr/bikestation_timeseries/urn%3Angsi-ld%3Astation%3A001/attrs/availableBikeNumber?fromDate=2025-01-06T00%3A00%3A00&toDate=2025-01-13T23%3A59%3A59"
# link5= "https://portail-api-data.montpellier3m.fr/bikestation_timeseries/urn%3Angsi-ld%3Astation%3A001/attrs/availableBikeNumber?fromDate=2025-01-13T00%3A00%3A00&toDate=2025-01-16T23%3A59%3A59"
# getAllParkData("bike",link1,1,4)
# getAllParkData("bike",link2,2,4)
# getAllParkData("bike",link3,3,4)
# getAllParkData("bike",link4,4,4)
# getAllParkData("bike",link5,5,4)

# Afin d'utiliser la fonction ci-dessus, il faut passer en argument :

# - "bike" si c'est pour les vélos
# - "car" si c'est pour les voitures
# - le lien de l'API (pour les vélos)
# - le numéro à mettre dans le nom du fichier (n) pour les semaines
# - l'indentation (indent) par défaut à 4

###################### DATA CAR ##################################

# Les deux arguments centraux ("None" et 5 ne servent que pour les vélos).
# getAllParkData("car","None",5,4)